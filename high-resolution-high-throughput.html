<!DOCTYPE html>
<html lang="en-US"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>High Resolution High Throughput | Primitives</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="High Resolution High Throughput" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="High resolution, high throughput (pt 2)" />
<meta property="og:description" content="High resolution, high throughput (pt 2)" />
<link rel="canonical" href="https://github.com/pages/manifoldfinance/primitives/high-resolution-high-throughput" />
<meta property="og:url" content="https://github.com/pages/manifoldfinance/primitives/high-resolution-high-throughput" />
<meta property="og:site_name" content="Primitives" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-10-11T00:00:00-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="High Resolution High Throughput" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-10-11T00:00:00-07:00","datePublished":"2022-10-11T00:00:00-07:00","description":"High resolution, high throughput (pt 2)","headline":"High Resolution High Throughput","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/pages/manifoldfinance/primitives/high-resolution-high-throughput"},"url":"https://github.com/pages/manifoldfinance/primitives/high-resolution-high-throughput"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="https://github.com/pages/manifoldfinance/primitives/feed.xml" title="Primitives" /><!-- Emoji Favicon  -->
  <!-- Favicon -->
  <link
    rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üéÑ</text></svg>"
  />
  <!-- <link rel="shortcut icon" href="/pages/manifoldfinance/primitives/favicon.ico"> -->

  <!-- Bootstrap CSS -->
  <link
    rel="stylesheet"
    href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"
    integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu"
    crossorigin="anonymous"
  />

  <!-- Font Awesome -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
    integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog=="
    crossorigin="anonymous"
  />

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/pages/manifoldfinance/primitives/assets/css/main.min.css" />
</head>
<body><!-- Navigation -->
<nav
  class="navbar navbar-default navbar-custom navbar-fixed-top invert"
>
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <a class="navbar-brand" href="/pages/manifoldfinance/primitives/">Primitives</a>
      <button class="navbar-toggle" type="button">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/pages/manifoldfinance/primitives/">Home</a>
          </li><li>
            <a href="/pages/manifoldfinance/primitives/about">About</a>
          </li><li>
            <a href="/pages/manifoldfinance/primitives/archive">Archive</a>
          </li><li class="search-icon">
            <a href="javascript:void(0)">
              <i class="fas fa-search"></i>
            </a>
          </li>
        </ul>
      </div>
    </div>
  </div>
</nav>
<!-- Search -->
<div class="search-page">
  <div class="search-icon-close-container">
    <span class="search-icon-close">
      <i class="fas fa-chevron-down"></i>
    </span>
  </div>

  <div class="search-main container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <form>
          <input type="text" id="search-input" placeholder="$ grep..." />
        </form>
        <div id="search-results" class="mini-post-list"></div>
      </div>
    </div>
  </div>
</div>
<!-- Post Header --><header
  class="intro-header style-text"
>
  <div class="header-mask"></div><div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-heading">
          <div class="tags"></div>
          <h1>High Resolution High Throughput</h1>
          <h2 class="subheading"></h2>
          <span class="meta"
            >Posted by manifoldfinance on October 11, 2022</span
          >
        </div>
      </div>
    </div>
  </div>
</header><!-- Post Content -->
<style>
  /* Place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: 0.1em;
    }
  }
</style>
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div
        class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"
      ><h2 id="high-resolution-high-throughput-pt-2">High resolution, high throughput (pt 2)</h2>

<blockquote>
  <p>source:
https://raw.githubusercontent.com/frankmcsherry/blog/master/posts/2017-03-01.md</p>
</blockquote>

<p>This post is about the second of two issues I outlined a while back in a
<a href="https://github.com/frankmcsherry/blog/blob/master/posts/2016-07-26.md">differential dataflow roadmap</a>.
I‚Äôve recently written a bit about the first issue,
<a href="https://github.com/frankmcsherry/blog/blob/master/posts/2017-02-11.md">performance degradation over time</a>,
and steps to ameliorate the issue. That seems to be mostly working now, and I‚Äôll
write a bit more about that as it settles.</p>

<p>Instead, we‚Äôll talk in this post about the second concern: with fine-grained
updates, perhaps just a few updates per timestamp, additional workers do not
increase the throughput of update processing (and they mostly slow it down).</p>

<p>Stealing
<a href="https://github.com/frankmcsherry/blog/blob/master/posts/2016-07-26.md#resolution-and-scaling">a figure from the roadmap post</a>,
let‚Äôs look at doing 10,000 updates to a reachability computation with two
million edges, but batching the 10,000 updates three different ways: one, ten,
and one hundred updates at a time:</p>

<p><img src="https://github.com/frankmcsherry/blog/blob/master/assets/roadmap/batching.png" alt="batching" /></p>

<p>The solid lines are the distributions of single-worker latencies, and the dotted
lines are the distributions of two-worker latencies. Visually, the second worker
helps when we have larger input batches and hurts when we have smaller input
batches. In fact, the second worker helps enough on the tail (up at the top of
the plot) that it always gives a throughput increase, but this seems like good
luck more than anything. We would like to see curves that look more like the
rightmost pair.</p>

<p>We would love to get the throughput scaling of larger batch sizes, so why not
always work with large batch sizes? The single-element updates provide something
valuable: very precise information about which input changes lead to which
output changes. By lumping all updates together in a larger batch, we lose
resolution on the effects of the changes. We have to dumb down the computation
to get the performance benefits, and that sucks.</p>

<p>In this post, I‚Äôll explain the plan to fix this.</p>

<h3 id="a-tale-of-three-loops">A tale of three loops</h3>

<p>Imagine you were asked to hand-write a program that gets provided with a
timestamped sequence of edge changes (additions, deletions) and you need to
provide the corresponding timestamped changes to the number of nodes at each
distance from node zero.</p>

<p>That is, the input looks a bit like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre> edge 	change 	 time
(0,3)       +1      0
(0,2)       +1      5
(2,3)       +1     10
(0,3)       -1     11
</pre></td></tr></tbody></table></code></pre></div></div>

<p>and your output should look something like</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>dist   change   time
   1       +1      0
   1       +1      5
   1       -1     11
   2       +1     11
</pre></td></tr></tbody></table></code></pre></div></div>

<p>where these counts are (I hope) the correct changes in counts for the distances
in the graph. Let me know if they are not.</p>

<hr />

<p>As an exercise, actually imagine this. How <em>would</em> you structure your
hand-written program?</p>

<hr />

<p>If I had to guess (and I do), I would guess that most people would write a
program that foremost (i) iterates forward over timestamps, for each time (ii)
iterates over distances from the root, and for each depth (iii) iterates over
reachable nodes and their edges to determine the reachable set of the next
depth.</p>

<p>That is, a program that looks roughly like</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>foreach time
    foreach depth (until converged)
        foreach node at depth
            set depth of neighbors to at most depth+1
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This program seems totally fine, and I suspect a normal computer scientist will
understand it better than the sort of loop we are going to end up with. To be
totally clear, we aren‚Äôt going to change the written program at all, we are just
going to execute our program differently. But, if we had to write a program to
explain how the execution works, it would look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>foreach depth (until converged)
    foreach node at depth
        foreach time
            set depth of neighbors at time to at most depth+1
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Oh geez. Why can‚Äôt we just write normal programs for once, huh?</p>

<p>Let‚Äôs walk through the loop ordering above, using our example just above. Recall</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre> edge 	change 	 time
(0,3)       +1      0
(0,2)       +1      5
(2,3)       +1     10
(0,3)       -1     11
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now, we do ‚Äútime‚Äù last, and we do iteration over depth first. So, that means
that we start with the depth 0 nodes. As it turns out there is just one, the
root (node <code class="language-plaintext highlighter-rouge">0</code>). We iterate over its edges, and determine which neighbors are
reachable at which times, and offer them ‚Äúdepth 1‚Äù. I think they are:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>(3,1)	    +1      0
(2,1)       +1      5
(3,1)       -1     11
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This is all we do for the first depth. We are now ready to head in to the next
depth, which is depth 1. These nodes (and their history) is highlighted just
above. When we line this up with edges, we get proposals for depth 2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>(3,2)       +1     10
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now, this proposal is mostly uninteresting to node <code class="language-plaintext highlighter-rouge">3</code>, except come time <code class="language-plaintext highlighter-rouge">11</code>.
At that time, node <code class="language-plaintext highlighter-rouge">3</code> does actually end up with depth 2, and so we want to do
another round of iteration. But, node <code class="language-plaintext highlighter-rouge">3</code> has no outgoing edges so there isn‚Äôt
anything to do.</p>

<p>Nothing in this execution required us to perform work in time order, except
possibly within a <code class="language-plaintext highlighter-rouge">(depth, key)</code> pair. We could literally take the whole input
history, if we had access to it, and compute the entire output history, doing
the computation depth-by-depth.</p>

<p>This is possible only because we have chosen to map functional computations
across input streams. This restriction on our computational model turns in to a
flexibility in how we execute the computation. Isn‚Äôt it just delightful when
that happens?</p>

<h3 id="why-would-we-do-this">Why would we do this?</h3>

<p>We can apparently pivot around iterative algorithms so that rather than
time-by-time, we do rounds of iterations. Why would we do that?</p>

<p>There are a few reasons I can think of, and they kinda boil down to the same
reason: the only sense in which data-parallel computation needs to wait on input
times is that work should be done in-order for each key.</p>

<ol>
  <li>
    <p><strong>Each distinct timestamp is some serious overhead in timely dataflow.</strong></p>

    <p>This is really annoying. Each distinct timestamp results in all of the
timely dataflow workers having a little chat. These chats can be boxcar‚Äôd
together, but we are sending bytes of coordination traffic around for each
distinct time. If there is one record for each time, we would be sending
much more coordination traffic than data traffic. If we only need to send
progress traffic for each iteration, rather than each (round, iteration), we
cut out untenable overhead.</p>
  </li>
  <li>
    <p><strong>Workers can proceed independently on decoupled times, scaling better.</strong></p>

    <p>When we worry about times <em>last</em>, workers can get more done without having
to coordinate. This means workers end up with larger hunks of work to
perform before they need to wait on others, and generally higher
utilization, and possibly higher throughput (we‚Äôll have to see).</p>
  </li>
  <li>
    <p><strong>Workers can re-order work across times to increase locality.</strong></p>

    <p>Even with a rich and complicated history of updates, workers can sort the
entire collection by key and do only one scan of key-indexed state. For each
key there may be many times to consider (in order!), but the worker only
needs to visit each key once, and in whichever order is most convenient.</p>
  </li>
</ol>

<p>There might be a few other cool reasons. Each one is an opportunity for me to
screw things up.</p>

<h3 id="making-this-happen">Making this happen</h3>

<p>What would it take to let us do this sort of transformation on iterative
computations? Run batches of input changes concurrently, before we have finished
all of the iterations of earlier batches? What black magic would we need to
summon this pow</p>

<p>Actually, timely dataflow already does this.</p>

<p>Ok, ok. Let‚Äôs remind ourselves about our reachability computation, which
iteratively joins current distances with edges to propose new distances to each
neighbor, followed by minimizing over the proposed distances for each node:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>    <span class="c1">// initialize roots as reaching themselves at distance 0</span>
    <span class="k">let</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">roots</span><span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="c1">// repeatedly update minimal distances each node can be reached from each root</span>
    <span class="n">nodes</span><span class="nf">.iterate</span><span class="p">(|</span><span class="n">inner</span><span class="p">|</span> <span class="p">{</span>

        <span class="k">let</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span><span class="nf">.enter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inner</span><span class="nf">.scope</span><span class="p">());</span>
        <span class="k">let</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="nf">.enter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inner</span><span class="nf">.scope</span><span class="p">());</span>

        <span class="c1">// propose dist+1 to neighbors, take mins.</span>
        <span class="n">inner</span><span class="nf">.join_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edges</span><span class="p">,</span> <span class="p">|</span><span class="n">_k</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">d</span><span class="p">|</span> <span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
             <span class="nf">.concat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nodes</span><span class="p">)</span>
             <span class="nf">.group</span><span class="p">(|</span><span class="n">_</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">|</span> <span class="n">t</span><span class="nf">.push</span><span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">})</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Before we do anything, let‚Äôs add one line after the <code class="language-plaintext highlighter-rouge">group</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>	<span class="nf">.inspect_batch</span><span class="p">(|</span><span class="n">t</span><span class="p">,</span><span class="n">_</span><span class="p">|</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"time: {:?}"</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This is going to tell us each time we see a batch of data produced by the
<code class="language-plaintext highlighter-rouge">group</code> operator (the ‚Äúmin‚Äù on depths), and at what logical time we see it. It
should clue us in to how the computation is actually being executed.</p>

<p>The code above is just the definition of the computation; we can run it a few
different ways.</p>

<h4 id="way-1-one-update-at-a-time">Way 1: One update at a time</h4>

<p>Let‚Äôs start with the traditional way we run these computations: we introduce a
change to an input edge, adding a new edge and removing an old edge, and we then
run the computation until the output reflects that change. In our timely code we
might write something like:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">for</span> <span class="n">round</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..</span> <span class="n">rounds</span> <span class="p">{</span>
    <span class="c1">// sliding window, let's pretend ...</span>
    <span class="n">graph</span><span class="nf">.send</span><span class="p">((</span><span class="n">edges</span><span class="p">[</span><span class="n">edge_count</span> <span class="o">+</span> <span class="n">round</span><span class="p">],</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">graph</span><span class="nf">.send</span><span class="p">((</span><span class="n">edges</span><span class="p">[</span><span class="n">round</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>

    <span class="c1">// advance input and run.</span>
    <span class="n">graph</span><span class="nf">.advance_to</span><span class="p">(</span><span class="n">round</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">computation</span><span class="nf">.step_while</span><span class="p">(||</span> <span class="n">probe</span><span class="nf">.lt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="nf">.time</span><span class="p">()));</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Here we push some changes into the computation, we advance the <code class="language-plaintext highlighter-rouge">graph</code> input
(important!), and then we let the computation run until our <code class="language-plaintext highlighter-rouge">probe</code> (definition
not shown) tells us that our output has caught up to the new input round.</p>

<p>Advancing the input is very important. This is what reveals to timely dataflow
that there will be no more input data with whatever timestamps have been left
behind, which is what allows it to pass this information along to differential
dataflow operators. Then they get to go and do some work.</p>

<p>Advancing is also what tells our <code class="language-plaintext highlighter-rouge">probe</code> that there can‚Äôt be any more output.
For homework, convince yourself that this version of the code doesn‚Äôt work:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">for</span> <span class="n">round</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..</span> <span class="n">rounds</span> <span class="p">{</span>
    <span class="n">graph</span><span class="nf">.advance_to</span><span class="p">(</span><span class="n">round</span><span class="p">);</span>
    <span class="n">graph</span><span class="nf">.send</span><span class="p">((</span><span class="n">edges</span><span class="p">[</span><span class="n">edge_count</span> <span class="o">+</span> <span class="n">round</span><span class="p">],</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">graph</span><span class="nf">.send</span><span class="p">((</span><span class="n">edges</span><span class="p">[</span><span class="n">round</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">computation</span><span class="nf">.step_while</span><span class="p">(||</span> <span class="n">probe</span><span class="nf">.le</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="nf">.time</span><span class="p">()));</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Back to breadth-first search and depth computation. I‚Äôm going to run the
computation one update at a time for ten rounds, on a graph with 100 nodes and
100 edges, like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>cargo run --example bfs -- 100 100 1 10
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This produces a bunch of output times, each of the form
<code class="language-plaintext highlighter-rouge">((Root, round), iteration)</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>time: ((Root, 0), 0)
time: ((Root, 0), 1)
time: ((Root, 0), 2)
time: ((Root, 0), 3)
time: ((Root, 0), 4)
time: ((Root, 2), 4)
time: ((Root, 2), 5)
time: ((Root, 5), 2)
time: ((Root, 5), 3)
time: ((Root, 7), 3)
time: ((Root, 7), 4)
time: ((Root, 9), 1)
time: ((Root, 10), 3)
time: ((Root, 10), 4)
time: ((Root, 10), 5)
time: ((Root, 10), 6)
time: ((Root, 10), 7)
time: ((Root, 10), 8)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As intended, we do all the work for one round before we proceed to the next
round. Within each round, we perform work by iteration, as we kinda need to do
one iteration before the next.</p>

<p>Actually, the <em>real</em> reason we do iterations in order is that timely dataflow
sees that there is a back-edge in our dataflow graph, and that updates at
<code class="language-plaintext highlighter-rouge">(round, iter)</code> can result in updates at <code class="language-plaintext highlighter-rouge">(round, iter+1)</code>. Timely dataflow does
not give the go-ahead to differential dataflow operators until all of the work
of the previous iteration has finished. That is why things actually happen in
iteration order.</p>

<p>Notice that there is not a back edge from ‚Äúprevious rounds‚Äù to ‚Äúsubsequent
rounds‚Äù. Timely dataflow can see that updates at <code class="language-plaintext highlighter-rouge">(round, iter)</code> cannot result
in updates at <code class="language-plaintext highlighter-rouge">(round+1, iter)</code>. What could the implications be ‚Ä¶</p>

<h4 id="way-2-update-all-the-things">Way 2: Update all the things!</h4>

<p>Let‚Äôs let timely and differential off the leash. Instead of holding back on
advancing the inputs, lets just put all the data in right away (but still at the
correct rounds):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">for</span> <span class="n">round</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..</span> <span class="n">rounds</span> <span class="p">{</span>
    <span class="c1">// sliding window, let's pretend ...</span>
    <span class="n">graph</span><span class="nf">.send</span><span class="p">((</span><span class="n">edges</span><span class="p">[</span><span class="n">edge_count</span> <span class="o">+</span> <span class="n">round</span><span class="p">],</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">graph</span><span class="nf">.send</span><span class="p">((</span><span class="n">edges</span><span class="p">[</span><span class="n">round</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">graph</span><span class="nf">.advance_to</span><span class="p">(</span><span class="n">round</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// run like crazy!</span>
<span class="n">computation</span><span class="nf">.step_while</span><span class="p">(||</span> <span class="n">probe</span><span class="nf">.lt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">graph</span><span class="nf">.time</span><span class="p">()));</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This version of the code just dumps all the data in, and only once it is done
does it go and start running the computation. At this point, timely knows that
the input can‚Äôt producing anything before <code class="language-plaintext highlighter-rouge">rounds</code>; what happens when
differential sees this information?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>time: ((Root, 0), 0)
time: ((Root, 0), 1)
time: ((Root, 0), 2)
time: ((Root, 5), 2)
time: ((Root, 9), 1)  &lt;-- wtf?
time: ((Root, 0), 3)
time: ((Root, 5), 3)
time: ((Root, 7), 3)
time: ((Root, 10), 3)
time: ((Root, 0), 4)
time: ((Root, 2), 4)
time: ((Root, 7), 4)
time: ((Root, 10), 4)
time: ((Root, 2), 5)
time: ((Root, 10), 5)
time: ((Root, 10), 6)
time: ((Root, 10), 7)
time: ((Root, 10), 8)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Chew on that for a bit.</p>

<p>Actually, I think this all makes a lot of sense if you ignore the <code class="language-plaintext highlighter-rouge">(9,1)</code> for
the moment. If you ignore that time, all of the other updates are done in
iteration order. Timely and differential agree that we can do the work for each
of the iteration <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code>, <code class="language-plaintext highlighter-rouge">4</code>, and <code class="language-plaintext highlighter-rouge">5</code> at the same time, even before all work
at prior rounds have completed.</p>

<p>The <code class="language-plaintext highlighter-rouge">(9,1)</code> update is a bit of a mystery, but nothing about differential
dataflow‚Äôs operator implementation guarantees that all work that can be
performed will be performed <em>immediately</em>. In particular, there are several
points where the operator learns it will need to do some more work, and enqueues
the work rather than testing whether the work can be done right away. The
apparent <code class="language-plaintext highlighter-rouge">(9,1)</code> disorder may just be a result of this. It‚Äôs not an incorrect
disorder, just work we could have done before <code class="language-plaintext highlighter-rouge">(0,2)</code> and <code class="language-plaintext highlighter-rouge">(5,2)</code> if we wanted
to.</p>

<h4 id="way-3-a-little-bit-of-both">Way 3: A little bit of both</h4>

<p>We could also do a bit of both: ingest some data, do some computation, ingest
some data, do some computation. This is a lot more like what we actually expect
in a streaming system. Taking all the timestamped input at once is more like a
temporal database (as I understand them), and taking the timestamped input only
one update at a time is like .. a bad streaming system I guess.</p>

<p>So let‚Äôs do that, doing a few rounds (three) of computation after each update,
but not necessarily running until all updates for the round are complete. What
do we see:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>time: ((Root, 0), 0)
time: ((Root, 0), 1)
time: ((Root, 0), 2)
time: ((Root, 0), 3)
time: ((Root, 5), 2)
time: ((Root, 0), 4)
time: ((Root, 2), 4)
time: ((Root, 5), 3)
time: ((Root, 7), 3)
time: ((Root, 2), 5)
time: ((Root, 7), 4)
time: ((Root, 9), 1)
time: ((Root, 10), 3)
time: ((Root, 10), 4)
time: ((Root, 10), 5)
time: ((Root, 10), 6)
time: ((Root, 10), 7)
time: ((Root, 10), 8)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This begins and ends pretty predictably, for obvious reasons (nothing to work on
at beginning / end other than the first / last update). But in the middle we see
some pretty neat stuff. I‚Äôm thinking specifically of</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>...
time: ((Root, 2), 5)
time: ((Root, 7), 4)
time: ((Root, 9), 1)
...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Here we‚Äôve got a neat little wave-front cutting through our <code class="language-plaintext highlighter-rouge">(round, iter)</code>
partial order. Each of these times are mutually incomparable (none can lead to
another), and they can all be processed concurrently.</p>

<h3 id="what-needs-to-be-different">What needs to be different</h3>

<p>If timely dataflow already lets us re-order the computation, and allows us to
process multi-element wavefronts concurrently, what is the problem?</p>

<p>Although timely gives operators enough information, there are several
implementation issues that emerge if we just let timely dataflow run free on
fine-grained timestamps.</p>

<ol>
  <li>
    <p><strong>Each timestamp has lots of overhead</strong></p>

    <p>We already mentioned that timely does coordination for each timestamp, and
that is still true a few sections later. If we want to avoid bogging down
the computation with control traffic, we‚Äôll need to think of a better way of
talking about all the different timestamps.</p>
  </li>
  <li>
    <p><strong>Differential operators run first by time, then by key</strong></p>

    <p>Even though timely informs the operators that they can re-order compuation
by iteration rather than by round, within an operator the implementations
still operate in blocks of logical time, rather than processing all
available times for each key. We‚Äôll want to fix this (for sanity), but it
also opens the door to improved locality (one pass over keys per
invocation).</p>
  </li>
</ol>

<p>These two problems have relatively tractable solutions, which I‚Äôll just spill
out there. Neither is properly implemented, but the first is in use in timely‚Äôs
logging infrastructure, and the second has been typed into comment out code.
Pretty serious business.</p>

<p>Honestly, the first step seems totally simple and workable, and I expect no
issues. The second step will likely eventually work, but it risks discovering
some horrible algorithmic nightmares along the way. That being said, here we go:</p>

<h4 id="step-1-high-resolution-streams">Step 1: High-resolution streams</h4>

<p>Right now update streams in differential take the form of timely dataflow
messages, where the data have the form</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>    <span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">diff</span><span class="p">):</span> <span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="nb">isize</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>There is some record, and a count indicating by how much it has changed. Like
all timely dataflow messages, there is a time attached to the message, and we
treat that as the time for all updates in the message. A timely dataflow message
therefore looks something like (but is actually nothing like):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>    <span class="p">(</span><span class="n">Time</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="nb">isize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>That is great if there are lots of updates with the same time, as they can get
bundled together. This doesn‚Äôt work especially well if, in the limit, there is
just one update for each time. In addition to the control traffic, each update
gets sent out as a singleton message with lots of associated overhead.</p>

<p>So, a different way of doing things, a more painful way if you don‚Äôt actually
need the flexibility, is to pack the times in as data as well, sending messages
like</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>    <span class="p">(</span><span class="n">Time</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">Time</span><span class="p">,</span> <span class="nb">isize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We have <code class="language-plaintext highlighter-rouge">Time</code> in there twice now, but the two uses serve different roles. The
first <code class="language-plaintext highlighter-rouge">Time</code> is timely dataflow‚Äôs ‚Äúcapability‚Äù. It tells timely dataflow, and
us, at which logical times downstream operators are allowed to send data by
virtue of holding on to this message. The second times tell us when changes
<em>actually</em> occur, but these times don‚Äôt need to be equal to that of the
capability; timely dataflow doesn‚Äôt know about them.</p>

<p>It turns out that for things to make sense, all of the second times should be
greater or equal to that of the capability. If a change occurs, it may
precipitate changes at that or future times, and we really want a capability
that allows us to send messages reflecting those times. Correspondingly, we want
timely dataflow‚Äôs promise that ‚Äúno messages with a given capability will arrive‚Äù
to have meanining; the completion of a capability timestamp will imply the
completion of the corresponding data timestamps.</p>

<p>So that‚Äôs the plan. Bundle up batches of <code class="language-plaintext highlighter-rouge">(D, Time, isize)</code> updates and send
them along with a capability that is less or equal to each of the times. Of
course we can‚Äôt just mint a capability out of nowhere, so it will really be the
reverse: grab a capability and use it to send all the pending updates at times
greater than or equal to its time. Once we‚Äôve sent everything we need to, throw
away the capability and let workers proceed to whatever bundles of times are
next.</p>

<p>If we ever end up needing to send an update in the future of no capability we
hold, we done screwed up.</p>

<h4 id="step-2-high-resolution-operators">Step 2: High-resolution operators</h4>

<p>Operators currently receive timely dataflow messages of the first (time-free)
form above, and receive progress information about the capabilities on those
messages. We will need to rethink both of these, as well as the general
structure of the operator‚Äôs logic.</p>

<p>Informally, a differential dataflow operator accepts input updates into a pile,
differentiated by timestamp. When it learns from its input that a timestamp in
its pile is finished, it picks up all the updates with that timestamp and
commits them. It then flips through all the keys in these committed updates, and
checks whether the operator logic applied to the input collection at this time
still produces the accumulated output at this time, and issues updates if not.</p>

<p>Actually it is a bit more complicated, but let‚Äôs not worry about that here.</p>

<p>The rough structure up above is time-by-time, but there is nothing much that
prevents it from operating in terms of time <em>intervals</em> rather than individual
times. You probably know what an interval is, right? Something like <code class="language-plaintext highlighter-rouge">[a, b)</code>
that says ‚Äú<code class="language-plaintext highlighter-rouge">a</code> and stuff up to but not including <code class="language-plaintext highlighter-rouge">b</code>‚Äù.</p>

<p>We are going to do this, but where <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are
<a href="https://en.wikipedia.org/wiki/Antichain">antichains</a>.</p>

<p>An antichain is a collection of mutually incomparable elements from a partial
order, and in timely dataflow it acts a bit like a line cut across the partial
order (not actually; that would be a
<a href="https://en.wikipedia.org/wiki/Antichain#Height_and_width">maximal antichain</a>).
We will speak of the interval <code class="language-plaintext highlighter-rouge">[a, b)</code> as those elements of the partial order
greater or equal to some element of <code class="language-plaintext highlighter-rouge">a</code>, but not greater or equal to any element
of <code class="language-plaintext highlighter-rouge">b</code>.</p>

<p>This may make more sense to think about an interval as those times that, from
the point of view of a differential dataflow operator, were not previously
complete (greater-or-equal to the prior input frontier) but are now complete
(not greater-or-equal to the current input frontier). As an operator executes,
the sequence of input frontiers it observes evolves, and each step defines an
interval of this form.</p>

<p>With that thought in mind, our plan is to have each operator first identify the
interval of newly completed times, say <code class="language-plaintext highlighter-rouge">[a,b)</code>, and then pull all updates with
times in this interval. I don‚Äôt know a great datastructure for this, so the
working plan is that all <code class="language-plaintext highlighter-rouge">(D, Time, isize)</code> updates are just going to be in a
big list that we scan each time the frontier changes. Once we pull out updates
at newly completed times, we order them by key and process each key
independently.</p>

<p>There are more details for sure, but once we are willing to just re-scan piles
of updates in the name of performance, many doors are open to us.</p>

<h4 id="organization">Organization</h4>

<p>I‚Äôm not sure I want to try and write operators that hybridize high-resolution
and low-resolution implementations. At the moment I‚Äôm more inclined to
specialize the <code class="language-plaintext highlighter-rouge">Collection</code> type, which wraps a stream of updates, into two
types:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">LoResCollection</code>, which has relatively few distinct times, and bundles data
without additional logical times as data.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">HiResCollection</code>, which has relatively many distinct times, and bundles
logical times in with the data.</p>
  </li>
</ol>

<p>These two types can now have separate implementations of <code class="language-plaintext highlighter-rouge">group</code> and <code class="language-plaintext highlighter-rouge">join</code> and
such. This does raise the question of what happens with <code class="language-plaintext highlighter-rouge">join</code> where the inputs
are different granularities, and I don‚Äôt know other than it is pretty easy to
promote a <code class="language-plaintext highlighter-rouge">LoResCollection</code> to a <code class="language-plaintext highlighter-rouge">HiResCollection</code> just by sticking the same
time in the payload. We could go the other way, but at an unboundedly horrible
cost, so let‚Äôs not.</p>

<p>Actually, the current <code class="language-plaintext highlighter-rouge">Trace</code> interface masks details about high-resolution vs
low-resolution, and operators like <code class="language-plaintext highlighter-rouge">join</code> just take pre-arranged traces rather
than weirdly typed <code class="language-plaintext highlighter-rouge">Collection</code> structs. It might be surprisingly non-horrible
to meld the two representations together, for example supporting a frequently
changing graph and an infrequently changing queries against it. I‚Äôm not sure how
we would choose which output type to produce, though (the higher-resolution, of
course, but how to determine this without specialization).</p>

<p>Related, we will evenutally want to meld high- and low-resolution trace
representations. Quickly changing edge sets call for a high-resolution
representation, but once the times have passed and we want to coalesce the
updates, the resulting updates change only with iterations and not rounds, and
admit a low-resolution representation. The low-resolution implementations can be
much more efficient than the high-resolution ones, because they avoid some
massive redundancy in re-transcribing the times with every update.</p>

<p>All in all, I think there are some great things to try out here, many likely
pitfalls, but some fairly cool potential. I‚Äôm optimistic that we will soon get
to a system that processes updates with high-resolution <em>and</em> high-throughput,
for as long as you run the system.</p>

<p>It will probably be slower on some batch graph compute, but are people really
still working on that stuff?</p>

<h3 id="addendum-a-prototype-march-5-2017">Addendum: A Prototype (March 5, 2017)</h3>

<p>I have a prototype up and running. It seems to produce the correct output, in
the sense that it produces exactly the same outputs whether you run it with one
update at a time, or one million updates at a time. Also, the output isn‚Äôt
empty; I thought to check that.</p>

<p>First up, let‚Äôs look at some measurements from the previous pile of code. This
previous pile takes batches of records which all have the same time. This means
that if you want each update to have its own timestamp, you get lots of small
batches. If you put multiple updates together in a batch, they all have the same
timestamp and their effects can‚Äôt be distinguished.</p>

<p>Using this implementation, let‚Äôs get some baseline measurements. We are going to
look at the breadth-first search computation (how many nodes are at each
distance from the root) doing one million updates to two random graphs, one with
1,000 nodes and 2,000 edges, and one with 1,000,000 nodes and 10,000,000 edges.
We will do the one million updates a few different ways, batching the updates in
batches of sizes from one up to one million (e.g. <code class="language-plaintext highlighter-rouge">10 x 100000</code> means batches of
size 10, done 100,000 times). All updates in a batch have the same timestamp.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">experiment</th>
      <th style="text-align: right">1k / 2k</th>
      <th style="text-align: right">1m / 10m</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1 x 1000000</td>
      <td style="text-align: right">142s</td>
      <td style="text-align: right">100s</td>
    </tr>
    <tr>
      <td style="text-align: right">10 x 100000</td>
      <td style="text-align: right">73s</td>
      <td style="text-align: right">64s</td>
    </tr>
    <tr>
      <td style="text-align: right">100 x 10000</td>
      <td style="text-align: right">27s</td>
      <td style="text-align: right">51s</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 x 1000</td>
      <td style="text-align: right">5s</td>
      <td style="text-align: right">48s</td>
    </tr>
    <tr>
      <td style="text-align: right">10000 x 100</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">34s</td>
    </tr>
    <tr>
      <td style="text-align: right">100000 x 10</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">21s</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000 x 1</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">12s</td>
    </tr>
  </tbody>
</table>

<p>We don‚Äôt have measurements for 10,000 and larger batch sizes for the small
graph, because with only 2,000 edges and the same timestamp for all the updates
in a batch, most of the changes would just cancel. I should say, although it is
trivial for the <code class="language-plaintext highlighter-rouge">1k / 2k</code> graph, the <code class="language-plaintext highlighter-rouge">1m / 10m</code> graph takes about eight seconds
to load its ten million edges, and these numbers include that.</p>

<p>Notice the massive discrepancy between single-element batches (142s and 100s)
and the larger batches (5s and 12s). This is a pretty substantial throughput
difference. We would love to get that throughput, or something close to it,
while keeping the resolution of single-element updates.</p>

<h4 id="the-prototype">The prototype</h4>

<p>There is some prototype code! Yay! It is <em>pretty weird</em> code, not like much I‚Äôve
written before. I‚Äôm quite certain there are inefficiencies in it, so the
absolute numbers are just an indication that we are moving in the right
direction. These are the same experiments as above, except here <em>every update
has a distinct timestamp</em>. We are producing the output that corresponds to the
<code class="language-plaintext highlighter-rouge">1 x 1000000</code> row from above, but without shattering all the updates into
different batches.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">experiment</th>
      <th style="text-align: right">1k / 2k</th>
      <th style="text-align: right">1m / 10m</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1 x 1000000</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: right">10 x 100000</td>
      <td style="text-align: right">237s</td>
      <td style="text-align: right">94s</td>
    </tr>
    <tr>
      <td style="text-align: right">100 x 10000</td>
      <td style="text-align: right">173s</td>
      <td style="text-align: right">75s</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 x 1000</td>
      <td style="text-align: right">148s</td>
      <td style="text-align: right">57s</td>
    </tr>
    <tr>
      <td style="text-align: right">10000 x 100</td>
      <td style="text-align: right">623s</td>
      <td style="text-align: right">43s</td>
    </tr>
    <tr>
      <td style="text-align: right">100000 x 10</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">31s</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000 x 1</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">25s</td>
    </tr>
  </tbody>
</table>

<p>There are several things different about this chart.</p>

<ol>
  <li>
    <p>First up, you may notice we didn‚Äôt do a batch size 1 row. There are some
things we do assuming there will be lots of work, and when there isn‚Äôt lots
of work we do it anyhow. The whole point of this research is to move to
larger batches. That being said, this will probably be fixed. These same
issues end up hurting the small graph more than the large graph; the small
graph is sparser, and updates cause longer cascades of small updates.</p>
  </li>
  <li>
    <p>We have a <code class="language-plaintext highlighter-rouge">10000 x 100</code> entry for the smaller graph! It makes sense to run
the experiment now, because each update with a different time doesn‚Äôt result
in cancelation. Unfortunately, it is terrible. The reason here seems to be
the same reason we had to do that
<a href="https://github.com/frankmcsherry/blog/blob/master/posts/2017-02-11.md">compaction</a>
stuff: with so many updates, each of the 1,000 keys gets a sizeable history,
and within a batch we are trying to process all of it without compacting it.
The makes us go quadratic in the number of updates per key per batch. The
good news is that we should be to do compaction on our own. The bad news is
that I have to code that up.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">1m / 10m</code> column doesn‚Äôt look so bad, does it? The times are worse than
before, for sure, but not by all that much. They are roughly ‚Äúone batch size
worse‚Äù, I think. And the results tell us the exact consequences of each
individual update, corresponding to the <code class="language-plaintext highlighter-rouge">1 x 1000000</code> row up above. I think
these could also get a bit better, because there are some fairly feeble
moments in the code.</p>
  </li>
</ol>

<p>Let‚Äôs take the <code class="language-plaintext highlighter-rouge">1m / 10m</code> experiment and crank up the number of workers. Note:
we are still producing the high-resolution outputs.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">experiment</th>
      <th style="text-align: right">1 worker</th>
      <th style="text-align: right">2 workers</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1 x 1000000</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: right">10 x 100000</td>
      <td style="text-align: right">94s</td>
      <td style="text-align: right">82s</td>
    </tr>
    <tr>
      <td style="text-align: right">100 x 10000</td>
      <td style="text-align: right">75s</td>
      <td style="text-align: right">58s</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 x 1000</td>
      <td style="text-align: right">57s</td>
      <td style="text-align: right">39s</td>
    </tr>
    <tr>
      <td style="text-align: right">10000 x 100</td>
      <td style="text-align: right">43s</td>
      <td style="text-align: right">28s</td>
    </tr>
    <tr>
      <td style="text-align: right">100000 x 10</td>
      <td style="text-align: right">31s</td>
      <td style="text-align: right">20s</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000 x 1</td>
      <td style="text-align: right">25s</td>
      <td style="text-align: right">15s</td>
    </tr>
  </tbody>
</table>

<p>Here, one worker takes 8s before it starts processing updates, and two workers
take 5s before they start processing updates. These numbers include those two
(and look a bit better if you mentally subtract that out).</p>

<p>This is pretty good news, I think. For small batches the second worker doesn‚Äôt
help much, which is what we should expect; the high-resolution changes don‚Äôt
improve the performance of small batches, they make larger batches produce the
same output. The larger batches do get a decent benefit from additional workers;
the scaling isn‚Äôt 2x, and it probably shouldn‚Äôt be (we have to do data exchange,
and flail around with some buffers).</p>

<p>This looks pretty promising to me. We can get the output that used to take us
92s (100s - 8s) now in just 10s to 15s. Or, maybe 23s if we want sub-second
response time. See, we need to take the total time and divide by the number of
batches to get the average response time, and we only get 1m updates / 10s
throughput if we want to wait for 10s. In fact, if that is our strategy there
are going to be some updates that take 20s before we see their implications.
We‚Äôd really like to draw down the numbers for the medium batch sizes.</p>

<p>There are for sure things to improve in the code, and I hope and expect these
numbers to come down. I‚Äôm also worried about (and planning on fixing) the
numbers for the smaller graph, which I‚Äôd very much like to work hitch-free. In
particular, I‚Äôd love to have an ‚Äúidiot-proof‚Äù implementation that just works for
any reasonable problem, without careful caveats about settings of batch sizes
and the like. Watch this space!</p>

<h3 id="addendum-small-message-optimization-march-7-2017">Addendum: Small message optimization (March 7, 2017)</h3>

<p>One of the ‚Äúthings we do assuming there will be lots of work‚Äù, alluded to above
as a reason we might have poor performance on small batch sizes, is radix sort.
As I‚Äôve written it, there are 256 numbers to go and check each time you radix
shuffle on a byte, because there are that many different bytes each record might
have produced. You do this for each byte position of (in this case) an
eight-byte key.</p>

<p>If you just have 10 elements to sort, just call <code class="language-plaintext highlighter-rouge">.sort()</code>.</p>

<p>I‚Äôve done that now. The times have improved, generally. Old times are in
parentheses:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">experiment</th>
      <th style="text-align: right">1k / 2k</th>
      <th style="text-align: right">1m / 10m</th>
      <th style="text-align: right">1m / 10m -w2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1 x 1000000</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: right">10 x 100000</td>
      <td style="text-align: right">157s (237s)</td>
      <td style="text-align: right">73s (94s)</td>
      <td style="text-align: right">64s (82s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100 x 10000</td>
      <td style="text-align: right">79s (173s)</td>
      <td style="text-align: right">58s (75s)</td>
      <td style="text-align: right">46s (58s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 x 1000</td>
      <td style="text-align: right">(148s)</td>
      <td style="text-align: right">53s (57s)</td>
      <td style="text-align: right">36s (39s)</td>
    </tr>
    <tr>
      <td style="text-align: right">10000 x 100</td>
      <td style="text-align: right">(623s)</td>
      <td style="text-align: right">41s (43s)</td>
      <td style="text-align: right">28s (28s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100000 x 10</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">(31s)</td>
      <td style="text-align: right">(20s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000 x 1</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">(25s)</td>
      <td style="text-align: right">(15s)</td>
    </tr>
  </tbody>
</table>

<p>Some measurements weren‚Äôt re-taken, under the premise that they shouldn‚Äôt be
improved (and I‚Äôm getting dodgy numbers the more my laptop runs and heats up).</p>

<p>The small instance still suffers from the second issue above: that the
implementation‚Äôs behavior is quadratic in the number of times per key in each
batch. For the <code class="language-plaintext highlighter-rouge">10000 x 100</code> experiment, several keys have more than 100 times,
resulting in 100x overhead that could be substantially reduced. I have a partial
solution for that, but it is vexxingly hard to do some things with general
partial orders that are so very, very simple for integers that just increase.</p>

<p>Even in the larger graph, we can see large numbers of times for each key. I had
<code class="language-plaintext highlighter-rouge">group</code> capture a histogram of the number of distinct times each key processes
in each batch, and for the <code class="language-plaintext highlighter-rouge">1000000 x 1</code> experiment (the largest batch size,
admittedly, but also one we thought was getting decent performance), we get
distributions of distinct times that look like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>counts[1]:	56707
counts[2]:	106391
counts[3]:	144178
counts[4]:	158547
counts[5]:	149205
counts[6]:	123057
counts[7]:	91704
counts[8]:	62347
counts[9]:	39843
counts[10]:	23667
counts[11]:	13367
counts[12]:	7006
counts[13]:	3644
counts[14]:	1823
counts[15]:	857
counts[16]:	347
counts[17]:	173
counts[18]:	67
counts[19]:	33
counts[20]:	19
counts[21]:	6
counts[22]:	3
counts[23]:	2
counts[24]:	1
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Most of the keys are doing some amount of redundant work here. Each time
currently rescans the input updates and re-accumulates collections, whereas most
of this work can be done just once and then updated as we move through times.
That‚Äôs not the whole story though, which will have to wait for the next
addendum.</p>

<h3 id="addendum-many-distinct-times-optimizations-march-24-2017">Addendum: Many distinct times optimizations (March 24, 2017)</h3>

<p>I have a candidate for <code class="language-plaintext highlighter-rouge">group</code> that works relatively well even with large
numbers of distinct times for each key. The details will need to wait for a
longer blog post, but they roughly amount to looking for totally ordered runs in
the times we work with, and (future work) re-arranging the times to have longer
runs. The result is an implementation that is linear (plus sorting) in the
number of updates, multiplied by the number of times that are not <code class="language-plaintext highlighter-rouge">gt</code> their
immediate predecessor.</p>

<p>This works great for total orders, and is a start for partial orders. I still
have some more to do with respect to re-ordering times to cut down on this
number, but already there are some improvements in running times. Here are
updated numbers with old execution times in parentheses (note: other
optimizations have happened along the way, so this isn‚Äôt just about a new
algorithm).</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">experiment</th>
      <th style="text-align: right">1k / 2k</th>
      <th style="text-align: right">1m / 10m</th>
      <th style="text-align: right">1m / 10m -w2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1 x 1000000</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: right">10 x 100000</td>
      <td style="text-align: right">117s (157s)</td>
      <td style="text-align: right">82s (73s)</td>
      <td style="text-align: right">68s (64s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100 x 10000</td>
      <td style="text-align: right">75s (79s)</td>
      <td style="text-align: right">65s (58s)</td>
      <td style="text-align: right">46s (46s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 x 1000</td>
      <td style="text-align: right">87s (148s)</td>
      <td style="text-align: right">58s (53s)</td>
      <td style="text-align: right">40s (36s)</td>
    </tr>
    <tr>
      <td style="text-align: right">10000 x 100</td>
      <td style="text-align: right">70s (623s)</td>
      <td style="text-align: right">47s (41s)</td>
      <td style="text-align: right">33s (28s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100000 x 10</td>
      <td style="text-align: right">131s</td>
      <td style="text-align: right">34s (31s)</td>
      <td style="text-align: right">21s (20s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000 x 1</td>
      <td style="text-align: right">385s</td>
      <td style="text-align: right">26s (25s)</td>
      <td style="text-align: right">19s (15s)</td>
    </tr>
  </tbody>
</table>

<p>As you can see, several numbers for the smaller graph got much better, and at
the same time the numbers for the larger graph got a bit worse. This makes
sense, as the code is certainly more sophisticated than before, and if the
problem didn‚Äôt exist (e.g. the larger graph) we are just paying a cost. That
being said, I bet we can recover these losses and more when we actually try and
optimize the implementations; if nothing else, we can just drop in to the
simpler implementation for small numbers of times and save the complex one for
large number of times.</p>

<p>Also in the measurements, the times for the small graph are not strictly
improving as we increase the batch size. This is probably a result of not really
nailing the smallest number of totally ordered chains yet, though I can‚Äôt really
confirm that yet. There are some other reasons that arbitrarily large batches
aren‚Äôt perfect for iterative algorithms (in each iteration we must at least pick
up previous updates, making each iteration take time linear in the sum of batch
sizes of prior iterations, rather than just their own size).</p>

<h3 id="addendum-fixing-some-deranged-allocation-march-26-2017">Addendum: Fixing some deranged allocation (March 26, 2017)</h3>

<p>You might notice in the numbers above a disappointing spike up to <code class="language-plaintext highlighter-rouge">87s</code> for the
small graph in the <code class="language-plaintext highlighter-rouge">1000 x 1000</code> configuration. It turns out this is because one
thousand updates, which turns into two thousand changes (one edge in, one edge
out), is just over the threshold we used for ‚Äúshould we radix sort or not?‚Äù.
This means that for these settings, we end up allocating some 256 buffers and
working with them a fair bit. And then we drop them on the floor so that we can
re-allocate them the next time around. Not very bright.</p>

<p>In fact, it was much sillier than that. The sorting happens as part of
separating an undifferentiated pile of updates into ‚Äúsealed‚Äù updates, those
whose times have passed and we are not ready to finalize, and updates that stay
in the pile. We were doing the ‚Äúshould we radix sort‚Äù based on the
undifferentiated number, rather than the number we would eventually have to sort
(those of finished times). Because of how partially ordered times work, and that
timely dataflow can only carry one capability at a time, we end up slicing these
batches even more finely when the frontier advances, so that we have several
small sealed sets. Each of them have the bad radix sorting allocate-and-drop
behavior.</p>

<p>So that should be fixed. I even pushed a new version of <code class="language-plaintext highlighter-rouge">timely_sort</code> (some
radix sorting code) that does less allocation. I‚Äôm not quite using it yet, but
even with the local fixes, numbers look better:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">experiment</th>
      <th style="text-align: right">1k / 2k</th>
      <th style="text-align: right">1m / 10m</th>
      <th style="text-align: right">1m / 10m -w2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1 x 1000000</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: right">10 x 100000</td>
      <td style="text-align: right">(117s)</td>
      <td style="text-align: right">(82s)</td>
      <td style="text-align: right">(68s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100 x 10000</td>
      <td style="text-align: right">(75s)</td>
      <td style="text-align: right">(65s)</td>
      <td style="text-align: right">(46s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 x 1000</td>
      <td style="text-align: right">63s (87s)</td>
      <td style="text-align: right">54s (58s)</td>
      <td style="text-align: right">36s (40s)</td>
    </tr>
    <tr>
      <td style="text-align: right">10000 x 100</td>
      <td style="text-align: right">61s (70s)</td>
      <td style="text-align: right">43s (47s)</td>
      <td style="text-align: right">28s (33s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100000 x 10</td>
      <td style="text-align: right">127s (131s)</td>
      <td style="text-align: right">31s (34s)</td>
      <td style="text-align: right">20s (21s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000 x 1</td>
      <td style="text-align: right">(385s)</td>
      <td style="text-align: right">23s (26s)</td>
      <td style="text-align: right">16s (19s)</td>
    </tr>
  </tbody>
</table>

<p>The configurations with batches smaller than one thousand really shouldn‚Äôt see
much change, and the much larger batches shouldn‚Äôt have <em>much</em> change (some
small batches emerge in the computation for larger batches). There is some
serious improvement for the small graph, and decent improvement for the large
graph. We are mostly regaining ground on the larger graph, having taken a hit
from the complexity of the new and complicated ‚Äúlinear-ish‚Äù algorithm.</p>

<p>What these numbers should tell you, though, is that all this code is new enough
that we are getting 10% improvements just by looking at it and removing the
stupid. I‚Äôm planning on doing a bit more of that next. For example, each time we
radix sort one thousand elements, we compute the hash of each eight times. Why
would we do that?</p>

<p>One appealing aspect of Rust (over managed languages) is that there is no reason
we shouldn‚Äôt be able to write the code that does what we think it should do, and
in this case we kinda think we should be able to sort some updates by key, zip
them along stashed state, and compute and ship output differences. Any thing
that takes time is either because (i) we aren‚Äôt actually doing that yet, or (ii)
we are doing it badly. Each of these should be fixable.</p>

<p>One problem is that I don‚Äôt actually know how fast we <em>should</em> be able to
compute one million related bfs computations. Should we hope to get the <code class="language-plaintext highlighter-rouge">1k/2k</code>
number down to one second? Why not? That seems like a good goal to aim for. Or
at least, we should understand what are the large number of fundamental
computations that prevent us from that goal.</p>

<h3 id="addendum-quadratic-behavior-in-join-march-31-2017">Addendum: Quadratic behavior in <code class="language-plaintext highlighter-rouge">join</code> (March 31, 2017)</h3>

<p>I found the source of the bad behavior for the small graph!</p>

<p>When shifting from ‚Äúeach batch contains one time‚Äù to ‚Äúbatches may contain
multiple times‚Äù I was pleased to find that the <code class="language-plaintext highlighter-rouge">join</code> logic still passed its
tests and didn‚Äôt seem to need any fixing. Wow was that wrong.</p>

<p>First, it turns out that <code class="language-plaintext highlighter-rouge">join</code> as written wasn‚Äôt even correct. It passed all
the tests because <code class="language-plaintext highlighter-rouge">bfs</code> (which I used as the ‚Äúintegration‚Äù test) never has both
of its join inputs vary at the same time. Sure the <code class="language-plaintext highlighter-rouge">edges</code> change and the
<code class="language-plaintext highlighter-rouge">dists</code> change, but it is always either one (new round of edge data) or the
other (new iteration). So I fixed that (the bug, not the test).</p>

<p>More interestingly, I think, it became patently clear that the implementation
would quite happily go quadratic even on joins where there was <em>no</em> output. Let
me explain how join used to work:</p>

<p>When joining two sources of data, we get sequences of batches of updates, each
of which looks kind of like a <code class="language-plaintext highlighter-rouge">Vec&lt;(K, V, T, R)&gt;</code> (where you should think of <code class="language-plaintext highlighter-rouge">R</code>
as <code class="language-plaintext highlighter-rouge">isize</code>). For each batch we receive, we want to join it with all batches
received so far on the <em>other</em> input. This is a fairly traditional streaming
equijoin. So we join one <code class="language-plaintext highlighter-rouge">batch</code> with the <code class="language-plaintext highlighter-rouge">trace</code> of all history for the other
input (probably compacted a bit; that isn‚Äôt the issue) on the other side:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">for</span> <span class="n">key</span> <span class="k">in</span> <span class="n">batch</span><span class="nf">.keys</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">val1</span><span class="p">,</span> <span class="n">time1</span><span class="p">,</span> <span class="n">diff1</span><span class="p">)</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">batch</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">{</span>
		<span class="k">for</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">val2</span><span class="p">,</span> <span class="n">time2</span><span class="p">,</span> <span class="n">diff2</span><span class="p">)</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">trace</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">output</span><span class="nf">.ship</span><span class="p">(((</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">),</span> <span class="n">time1</span><span class="nf">.join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time2</span><span class="p">),</span> <span class="n">diff1</span> <span class="o">*</span> <span class="n">diff2</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Amazingly, due to bi-lineary of <code class="language-plaintext highlighter-rouge">join</code> and the way differential dataflow
difference work, this is actually correct. Even more clearly, this will do an
amount of work proportional to the product of the sizes of <code class="language-plaintext highlighter-rouge">batch</code> and <code class="language-plaintext highlighter-rouge">trace</code>.
That makes some sense, because we probably expect to see an output for each pair
of values in <code class="language-plaintext highlighter-rouge">batch</code> and <code class="language-plaintext highlighter-rouge">trace</code>, right?</p>

<p>WRONG!</p>

<p>This is where I started to think that maybe I should read about temporal
databases or something, rather than ‚Äúdiscovering‚Äù all this stuff myself. Over
the course of the history of <code class="language-plaintext highlighter-rouge">batch</code> and <code class="language-plaintext highlighter-rouge">trace</code>, the collections may never grow
to be all that big. In fact, they could totally alternate empty / non-empty out
of sync, in which case there would be no matches. All we would need to do to see
this would be to play each history in order, which takes time linear in the
inputs.</p>

<p>So I wrote a better inner loop for join when the histories are big and scary
(and fall back to the default implementation when they are not). The idea is
roughly to walk through the histories in order, maintaining each collection‚Äôs
updates accumulated with respect to the remaining frontier of times for the
other collection (for total orders, read this as: ‚Äúupdated in place‚Äù).</p>

<p>Returning to our trusty <code class="language-plaintext highlighter-rouge">bfs</code> experiment, we get new numbers that look like (old
numbers in parentheses):</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">experiment</th>
      <th style="text-align: right">1k / 2k</th>
      <th style="text-align: right">1m / 10m</th>
      <th style="text-align: right">1m / 10m -w2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1 x 1000000</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: right">10 x 100000</td>
      <td style="text-align: right">(117s)</td>
      <td style="text-align: right">(82s)</td>
      <td style="text-align: right">(68s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100 x 10000</td>
      <td style="text-align: right">(75s)</td>
      <td style="text-align: right">(65s)</td>
      <td style="text-align: right">(46s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 x 1000</td>
      <td style="text-align: right">62s (63s)</td>
      <td style="text-align: right">56s (54s)</td>
      <td style="text-align: right">38s (36s)</td>
    </tr>
    <tr>
      <td style="text-align: right">10000 x 100</td>
      <td style="text-align: right">59s (61s)</td>
      <td style="text-align: right">47s (43s)</td>
      <td style="text-align: right">32s (28s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100000 x 10</td>
      <td style="text-align: right">69s (127s)</td>
      <td style="text-align: right">36s (31s)</td>
      <td style="text-align: right">23s (20s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000 x 1</td>
      <td style="text-align: right">73s (385s)</td>
      <td style="text-align: right">32s (23s)</td>
      <td style="text-align: right">21s (16s)</td>
    </tr>
  </tbody>
</table>

<p>This is, much like a post or two back, a serious improvement for the small
graph, and a non-trivial regression for the larger graph.</p>

<p>I‚Äôm not entirely sure what is wrong with the larger graph, in that the join
implementation is largely the same for uncomplicated histories, except that it
must first extract the history to check if it is complicated; the old
implementation didn‚Äôt have to copy data out from <code class="language-plaintext highlighter-rouge">batch</code> and <code class="language-plaintext highlighter-rouge">trace</code> to look at
it, which is perhaps the issue? I feel like we can eventually work around that,
especially given that batch exfiltration of data should be faster than the
careful navigation we were (and still are, unfortunately) doing to read the
data.</p>

<p>Looking at a profile, the large graph <code class="language-plaintext highlighter-rouge">1000000 x 1</code> experiment spends only 6% of
its time in <code class="language-plaintext highlighter-rouge">join</code> at all, so the serious regression seems unlikely to live
there. I don‚Äôt think I‚Äôve changed <code class="language-plaintext highlighter-rouge">group</code> in the meantime, so I‚Äôm not exactly
sure what is screwed up; perhaps I tweaked the measurement program
inappropriately, or perhaps I caught a dodgy measurement the previous time
around (when there was, in fairness, a buggy join implementation).</p>

<p>For the small graph, the bulk of the time is now spent in <code class="language-plaintext highlighter-rouge">group</code>, in some
operations that may still have some defective performance (sorting mostly, it
seems; technically super-linear). It would be great to get performance to
improve with increasing batch size before starting to optimize the
implementations.</p>

<h3 id="addendum-simplifying-interesting-times-march-31-2017">Addendum: Simplifying ‚Äúinteresting times‚Äù (March 31, 2017)</h3>

<p>One complicated bit of logic in <code class="language-plaintext highlighter-rouge">group</code> determines the logical times at which we
may need to re-evaluate user logic. It is not so much complicated, as much as I
made it complicated. The logic is meant to take two sets of times, <code class="language-plaintext highlighter-rouge">old</code> and
<code class="language-plaintext highlighter-rouge">new</code> let‚Äôs say, and determine the times that are the lattice join of a subset
of <code class="language-plaintext highlighter-rouge">old</code> and a non-empty subset of <code class="language-plaintext highlighter-rouge">new</code>.</p>

<p>For example, here is the reference implementation that I wrote (here <code class="language-plaintext highlighter-rouge">edits</code> is
the old set and <code class="language-plaintext highlighter-rouge">times</code> is the new set):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="c1">// REFERENCE IMPLEMENTATION (LESS CLEVER)</span>
<span class="k">let</span> <span class="n">times_len</span> <span class="o">=</span> <span class="n">times</span><span class="nf">.len</span><span class="p">();</span>
<span class="k">for</span> <span class="n">position</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..</span> <span class="n">times_len</span> <span class="p">{</span>
    <span class="k">for</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="k">ref</span> <span class="n">time</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">in</span> <span class="n">edits</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">time</span><span class="nf">.le</span><span class="p">(</span><span class="o">&amp;</span><span class="n">times</span><span class="p">[</span><span class="n">position</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">join</span> <span class="o">=</span> <span class="n">time</span><span class="nf">.join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">times</span><span class="p">[</span><span class="n">position</span><span class="p">]);</span>
            <span class="n">times</span><span class="nf">.push</span><span class="p">(</span><span class="n">join</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="n">times</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mi">0</span> <span class="o">..</span> <span class="n">position</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">times</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="nf">.le</span><span class="p">(</span><span class="o">&amp;</span><span class="n">times</span><span class="p">[</span><span class="n">position</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">join</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="nf">.join</span><span class="p">(</span><span class="o">&amp;</span><span class="n">times</span><span class="p">[</span><span class="n">position</span><span class="p">]);</span>
            <span class="n">times</span><span class="nf">.push</span><span class="p">(</span><span class="n">join</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">position</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">times</span><span class="p">[</span><span class="n">position</span><span class="o">..</span><span class="p">]</span><span class="nf">.sort</span><span class="p">();</span>
    <span class="n">times</span><span class="nf">.dedup</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>It does a bunch of work, much more than the possibly linear-time implementation
I worked hard on. Of course, it is so much simpler (by about 80 lines, and many
loops), and we should probably just use it when we don‚Äôt have lots of edits.
Because often we don‚Äôt have lots of edits.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">experiment</th>
      <th style="text-align: right">1k / 2k</th>
      <th style="text-align: right">1m / 10m</th>
      <th style="text-align: right">1m / 10m -w2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1 x 1000000</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: right">10 x 100000</td>
      <td style="text-align: right">(117s)</td>
      <td style="text-align: right">(82s)</td>
      <td style="text-align: right">(68s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100 x 10000</td>
      <td style="text-align: right">(75s)</td>
      <td style="text-align: right">(65s)</td>
      <td style="text-align: right">(46s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 x 1000</td>
      <td style="text-align: right">58s (62s)</td>
      <td style="text-align: right">55s (56s)</td>
      <td style="text-align: right">38s (38s)</td>
    </tr>
    <tr>
      <td style="text-align: right">10000 x 100</td>
      <td style="text-align: right">56s (59s)</td>
      <td style="text-align: right">46s (47s)</td>
      <td style="text-align: right">30s (32s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100000 x 10</td>
      <td style="text-align: right">67s (69s)</td>
      <td style="text-align: right">35s (36s)</td>
      <td style="text-align: right">23s (23s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000 x 1</td>
      <td style="text-align: right">74s (73s)</td>
      <td style="text-align: right">31s (32s)</td>
      <td style="text-align: right">23s (21s)</td>
    </tr>
  </tbody>
</table>

<p>These are pretty minor effects, with some light improvement in the smaller batch
sizes where we expect less complicated histories. I was initially really excited
about this because I conflated the improvements with the next optimization, but
once I broke them apart this was not the better part. Sorry!</p>

<h3 id="addendum-avoiding-expensive-hashing-march-31-2017">Addendum: Avoiding expensive hashing (March 31, 2017)</h3>

<p>What actually makes a difference is ripping out a fair amount of redundant
hashing. Our default storage uses hash tables to index data by key, which is
really helpful when we have relatively few keys in each batch. At the same time,
our default implementation just calls each types associated hash function when
it needs a hash, which can be quite a lot.</p>

<p>In particular, when we first arrange data into batches we sort it (by key, then
value, then time), and while this is primarily a radix sort using the hash, we
need to finish it with a standard Rust sort to deal with possible hash
collisions and to get values and times ordered too. If we have lots of data, and
especially if we have lots of equivalent keys, this ends up calling the hash
function on the key quite a lot.</p>

<p>There is a small change we can make to cache the hash value; doing that doesn‚Äôt
seem to help all that much; it probably makes sorting faster but then costs
later on when we need to move around keys and hash values together. This is
worth looking into more, because if you show up with long <code class="language-plaintext highlighter-rouge">String</code> keys you
aren‚Äôt going to want lots of hash re-evaluation.</p>

<p>A simple change, for the purposes of graphs, is to use random node identifiers
and have each identifier be its own hash value. This works out great, and we get
generally improved performance:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">experiment</th>
      <th style="text-align: right">1k / 2k</th>
      <th style="text-align: right">1m / 10m</th>
      <th style="text-align: right">1m / 10m -w2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1 x 1000000</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: right">10 x 100000</td>
      <td style="text-align: right">(117s)</td>
      <td style="text-align: right">(82s)</td>
      <td style="text-align: right">(68s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100 x 10000</td>
      <td style="text-align: right">(75s)</td>
      <td style="text-align: right">(65s)</td>
      <td style="text-align: right">(46s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 x 1000</td>
      <td style="text-align: right">51s (58s)</td>
      <td style="text-align: right">51s (55s)</td>
      <td style="text-align: right">31s (38s)</td>
    </tr>
    <tr>
      <td style="text-align: right">10000 x 100</td>
      <td style="text-align: right">51s (56s)</td>
      <td style="text-align: right">38s (46s)</td>
      <td style="text-align: right">25s (30s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100000 x 10</td>
      <td style="text-align: right">60s (67s)</td>
      <td style="text-align: right">28s (35s)</td>
      <td style="text-align: right">19s (23s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000 x 1</td>
      <td style="text-align: right">66s (74s)</td>
      <td style="text-align: right">24s (31s)</td>
      <td style="text-align: right">17s (23s)</td>
    </tr>
  </tbody>
</table>

<p>This recovers a fair chunk of time we lost previously, and this difference could
actually be the source of the apparent regression (perhaps I was using this
version before; I certainly have in the past).</p>

<p>One question this raises is whether we really need hash tables as the index
structure. They are helpful for sparse access, but if our plan is to push hard
on throughput, perhaps simple ordered lists are good enough. They are much
simpler to construct, and very cheap to merge. They would likely kill the
numbers for small batch sizes, effectively raising the ‚Äúminimum latency‚Äù you
would experience for small loads. This will also be fun to check out, though.</p>

<p>Plus we are actually going to put real indices in place at some point, which
should make the distinction less important.</p>

<p>We still have an up-tick for increasing batch sizes in the small graph, and I
still want to sort that out. Removing all this hashing is one way of getting rid
of the noise that is leaving the source of the problem a mystery.</p>

<h3 id="addendum-re-engineering-group-april-2-2017">Addendum: Re-engineering <code class="language-plaintext highlighter-rouge">group</code> (April 2, 2017)</h3>

<p>I did a bit of a re-write of the core <code class="language-plaintext highlighter-rouge">group</code> logic. Not much has changed
algorithmically, but certain parts were tidied up enough that we spend less time
futzing around with messy piles of data.</p>

<p>For example, previously the operator accepted batches of keyed input data, and
for each key flipped through all times to create a list of <code class="language-plaintext highlighter-rouge">(key, time)</code> pairs
we should look into. That‚Äôs great, but we didn‚Äôt really need to do that; we can
just wait until we start to work on the key, and put together the list of times
for that key. This required a bit of sanity checking about ‚Äúexactly what times
are we planning on working on‚Äù that was enabled by the simplified code
structure.</p>

<p>We also bite off a larger chunk of the graph to work on, doing only one sweep
through the keys where we may previously have done several, feeding the output
into different batches as appropriate (when we have multiple incomparable
capabilities).</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">experiment</th>
      <th style="text-align: right">1k / 2k</th>
      <th style="text-align: right">1m / 10m</th>
      <th style="text-align: right">1m / 10m -w2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1 x 1000000</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: right">10 x 100000</td>
      <td style="text-align: right">(117s)</td>
      <td style="text-align: right">(82s)</td>
      <td style="text-align: right">(68s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100 x 10000</td>
      <td style="text-align: right">(75s)</td>
      <td style="text-align: right">(65s)</td>
      <td style="text-align: right">(46s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 x 1000</td>
      <td style="text-align: right">45s (51s)</td>
      <td style="text-align: right">57s (51s)</td>
      <td style="text-align: right">44s (31s)</td>
    </tr>
    <tr>
      <td style="text-align: right">10000 x 100</td>
      <td style="text-align: right">39s (51s)</td>
      <td style="text-align: right">43s (38s)</td>
      <td style="text-align: right">30s (25s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100000 x 10</td>
      <td style="text-align: right">48s (60s)</td>
      <td style="text-align: right">29s (28s)</td>
      <td style="text-align: right">19s (19s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000 x 1</td>
      <td style="text-align: right">55s (66s)</td>
      <td style="text-align: right">20s (24s)</td>
      <td style="text-align: right">12s (17s)</td>
    </tr>
  </tbody>
</table>

<p>Some interesting things happen here. The small graph performance improves a fair
bit, the very large batch performance improves quite a bit (more on this), and
the small batch large graph performance takes a bit of a hit. I‚Äôm not exactly
sure what the deal is here, except that we are doing more work in larger batches
now, and this provides both opportunities to do things well and to do things
badly.</p>

<p>I want to call out the large graph, multiple worker numbers. There is a pretty
serious improvement there, which is even more impressive when you learn that the
first 4.5 second are just prepping the computation (loading the graph and doing
the initial bfs computation). So what we are actually seeing appears to by 12s
of compute down to 8s of compute. I just need to do that a few more times. Also,
make sure to run integration test to see that we are producing the correct
output (ed: apparently).</p>

<h3 id="addendum-less-interesting-times-april-7-2017">Addendum: Less interesting times (April 7, 2017)</h3>

<p>I made what I think of as a pretty substantial change to the way <code class="language-plaintext highlighter-rouge">group</code> works.
Let me recap, both because it gets us on the same page, and because I need the
practice.</p>

<p>The <code class="language-plaintext highlighter-rouge">group</code> operator works on a bunch of keys in parallel, and for our purposes
we are just going to talk about what it does for each key individually (it maps
this behavior across all keys).</p>

<p>The <code class="language-plaintext highlighter-rouge">group</code> operator repeatedly gets presented with batches of updates each of
which corresponds to an <em>interval</em> of partially ordered time: <code class="language-plaintext highlighter-rouge">[lower, upper)</code>,
where <code class="language-plaintext highlighter-rouge">lower</code> and <code class="language-plaintext highlighter-rouge">upper</code> are both antichains (sets whose elements are mutually
incomparable) and the interval includes those times greater or equal to an
element of <code class="language-plaintext highlighter-rouge">lower</code> but not greater or equal to any element of <code class="language-plaintext highlighter-rouge">upper</code>.</p>

<p>When presented with an interval of updates, the <code class="language-plaintext highlighter-rouge">group</code> operator is now in a
position to determine the corresponding interval of updates to its output. All
of the inputs updates at times not after <code class="language-plaintext highlighter-rouge">upper</code> have been locked in, and this
means that mathematically that all of the output updates at times not after
<code class="language-plaintext highlighter-rouge">upper</code> are also locked in, we just haven‚Äôt computed them yet. So the <code class="language-plaintext highlighter-rouge">group</code>
operator needs to determine the output updates at times in the interval
<code class="language-plaintext highlighter-rouge">[lower, upper)</code>.</p>

<p>The previous implementation did this by tracking all of the times at which the
output might change, and each time around seeing which of these times are in the
interval <code class="language-plaintext highlighter-rouge">[lower, upper)</code> and working on those times. This was intended to be
very precise, but it has some serious overhead and, counter-intuitively, can end
up less precise that simpler methods.</p>

<p>The current implementation (this is all a work in progress) just takes as input
<code class="language-plaintext highlighter-rouge">lower</code> and <code class="language-plaintext highlighter-rouge">upper</code>, and starts looking for times that land in this interval. A
time is plausibly interesting, in that it could possibly have a non-zero output
update, if it is the join of sets of times found in input or output updates. As
we are (currently) planning on walking through all updates anyhow (to ‚Äúsimulate‚Äù
the history of the values for the key), we have the opportunity to start forming
these sets of joined things and seeing which land in our target interval.</p>

<p>Although we might consider lots of times, each time will either be (i) in the
<code class="language-plaintext highlighter-rouge">[lower, upper)</code> interval, in which case we want to reconsider it, or (ii) at
<code class="language-plaintext highlighter-rouge">upper</code> or beyond, in which case we should defer it for future processing. We
can also skip any times in the future of defered times, because we‚Äôll just
re-discover them when we get to them in the future, right?</p>

<p>Or will we?</p>

<p>This is meant to be the ‚Äúgood news‚Äù of this approach: if in the future it turns
out that the updates that prompted some possibly interesting time vanish,
perhaps because they cancel when seen from this point in the future, then great!
Although we thought it might be worth looking in to what the input and output
look like at that time, if by the time we get to the interval containing the
time the updates just aren‚Äôt there any more, no work for us to do!</p>

<p>Let‚Äôs look at an example: Imagine we are supplying one thousand rounds of input
to an iterative computation, so timestamps look like <code class="language-plaintext highlighter-rouge">(round, iteration)</code>. We
might start with updates that look like</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>("hello", (17, 0), +1)
("world", (23, 0), +1)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Meaning that <code class="language-plaintext highlighter-rouge">"hello"</code> shows up in the 17th round of input and <code class="language-plaintext highlighter-rouge">"world"</code> shows
up in the 23rd round of input. Perhaps over the course of the iterative
computation, the <code class="language-plaintext highlighter-rouge">"world"</code> record evolves a bit and eventually goes away</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>("world", (23, 3), -1)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Of course, <code class="language-plaintext highlighter-rouge">"hello"</code> can evolve too, and perhaps in a later iteration it prompts
something exciting:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>("wombat", (17, 5), +1)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This is very exciting, because wombats are magical animals. Now, based on our
tradition reasoning, in addition to our general excitement about wombats we may
also come to the conclusion that the time <code class="language-plaintext highlighter-rouge">(23, 5)</code> is pretty interesting. Some
stuff happens at <code class="language-plaintext highlighter-rouge">(_, 5)</code>, and some stuff happens at <code class="language-plaintext highlighter-rouge">(23, _)</code>, so stuff
probably happens at <code class="language-plaintext highlighter-rouge">(23, 5)</code> that we should check out.</p>

<p>As it turns out, nothing happens at <code class="language-plaintext highlighter-rouge">(23, 5)</code>, because by the time we‚Äôve gotten
to iteration five, the <code class="language-plaintext highlighter-rouge">"world"</code> updates have canceled with each other. The
input collection is identical to the collection at <code class="language-plaintext highlighter-rouge">(23, 4)</code> and at <code class="language-plaintext highlighter-rouge">(22, 5)</code>
and even at <code class="language-plaintext highlighter-rouge">(22, 4)</code>, which pretty much means that it doesn‚Äôt experience change
and so its output doesn‚Äôt change either.</p>

<p>Our prior implementations, each of which tracked all possibly interesting times
explicitly, would miss this opportunity because they flagged the times <code class="language-plaintext highlighter-rouge">(17,3)</code>
and <code class="language-plaintext highlighter-rouge">(19,3)</code> as interesting, and lost track of the fact that their reasons for
being interesting cancel each other out. When we arrive at <code class="language-plaintext highlighter-rouge">(23, 0)</code> we would be
warned about the excitement associated with <code class="language-plaintext highlighter-rouge">(19, 3)</code> and</p>

<p>So that‚Äôs all a very nice hypothetical optimization, but what does it do for our
<code class="language-plaintext highlighter-rouge">bfs</code> computation?</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">experiment</th>
      <th style="text-align: right">1k / 2k</th>
      <th style="text-align: right">1m / 10m</th>
      <th style="text-align: right">1m / 10m -w2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1 x 1000000</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: right">10 x 100000</td>
      <td style="text-align: right">(117s)</td>
      <td style="text-align: right">(82s)</td>
      <td style="text-align: right">(68s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100 x 10000</td>
      <td style="text-align: right">(75s)</td>
      <td style="text-align: right">(65s)</td>
      <td style="text-align: right">(46s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 x 1000</td>
      <td style="text-align: right">40s (45s)</td>
      <td style="text-align: right">59s (57s)</td>
      <td style="text-align: right">45s (44s)</td>
    </tr>
    <tr>
      <td style="text-align: right">10000 x 100</td>
      <td style="text-align: right">39s (39s)</td>
      <td style="text-align: right">45s (43s)</td>
      <td style="text-align: right">31s (30s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100000 x 10</td>
      <td style="text-align: right">49s (48s)</td>
      <td style="text-align: right">30s (29s)</td>
      <td style="text-align: right">20s (19s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000 x 1</td>
      <td style="text-align: right">55s (56s)</td>
      <td style="text-align: right">18s (20s)</td>
      <td style="text-align: right">11s (12s)</td>
    </tr>
  </tbody>
</table>

<p>Not a great deal. There is a little bit of movement, but I think most of it is
attributable to noise.</p>

<p>This is sort of good news, because we haven‚Äôt actually put the optimization of
ignoring canceling times into place yet, we are just seeing how well we do when
we have to rediscover times in each <code class="language-plaintext highlighter-rouge">[lower, upper)</code> interval rather than having
them listed for us. We removed a fair amount of ‚Äútime management‚Äù code, at the
possible cost of re-evaluating the user logic at more times than strictly
necessary. Though, practically, I‚Äôm not sure we actually do any more evaluation
this way, as we were fairly conservative about which times we would consider
previously (in that we considered quite a lot).</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">experiment</th>
      <th style="text-align: right">1k / 2k</th>
      <th style="text-align: right">1m / 10m</th>
      <th style="text-align: right">1m / 10m -w2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1 x 1000000</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
      <td style="text-align: right">-</td>
    </tr>
    <tr>
      <td style="text-align: right">10 x 100000</td>
      <td style="text-align: right">(117s)</td>
      <td style="text-align: right">(82s)</td>
      <td style="text-align: right">(68s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100 x 10000</td>
      <td style="text-align: right">(75s)</td>
      <td style="text-align: right">(65s)</td>
      <td style="text-align: right">(46s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 x 1000</td>
      <td style="text-align: right">40s (40s)</td>
      <td style="text-align: right">59s (57s)</td>
      <td style="text-align: right">42s (45s)</td>
    </tr>
    <tr>
      <td style="text-align: right">10000 x 100</td>
      <td style="text-align: right">36s (39s)</td>
      <td style="text-align: right">44s (45s)</td>
      <td style="text-align: right">30s (30s)</td>
    </tr>
    <tr>
      <td style="text-align: right">100000 x 10</td>
      <td style="text-align: right">46s (49s)</td>
      <td style="text-align: right">30s (30s)</td>
      <td style="text-align: right">20s (20s)</td>
    </tr>
    <tr>
      <td style="text-align: right">1000000 x 1</td>
      <td style="text-align: right">56s (55s)</td>
      <td style="text-align: right">18s (18s)</td>
      <td style="text-align: right">10s (11s)</td>
    </tr>
  </tbody>
</table>


        <!-- Post Pager -->
        <div>
          <hr style="visibility: hidden" />
          <ul class="pager"><li class="previous">
              <a
                href="/pages/manifoldfinance/primitives/differential-dataflow-pt1"
                data-toggle="tooltip"
                data-placement="top"
                title="Differential Dataflow Pt1"
              >
                Previous<br />
                <span>Differential Dataflow Pt1</span>
              </a>
            </li><li class="next">
              <a
                href="/pages/manifoldfinance/primitives/optimal-autonomous-organizations"
                data-toggle="tooltip"
                data-placement="top"
                title="Optimal autonomous organizations"
              >
                Next<br />
                <span>Optimal autonomous organizations</span>
              </a>
            </li></ul>
          <hr style="visibility: hidden" />
        </div></div><!-- Side Catalog Container -->
      <div
        class="col-lg-2 col-lg-offset-0 visible-lg-block sidebar-container catalog-container"
      >
        <div class="side-catalog">
          <hr class="hidden-sm hidden-xs" />
          <h5>
            <a class="catalog-toggle" href="#">CATALOG</a>
          </h5>
          <ul class="catalog-body"></ul>
        </div>
      </div><!-- Sidebar Container -->
      <div
        class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"
      ><!-- Featured Tags -->
<section><hr class="hidden-sm hidden-xs"><h5>
        <a href="/pages/manifoldfinance/primitives/archive/">FEATURED TAGS</a>
    </h5>
    <div class="tags"><a data-sort="0014"
            href="/pages/manifoldfinance/primitives/archive/?tag=distributed+computing"
            title="distributed computing"
            rel="3">distributed computing</a><a data-sort="0014"
            href="/pages/manifoldfinance/primitives/archive/?tag=ethereum"
            title="ethereum"
            rel="3">ethereum</a><a data-sort="0015"
            href="/pages/manifoldfinance/primitives/archive/?tag=blockchain"
            title="blockchain"
            rel="2">blockchain</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=DAO"
            title="DAO"
            rel="1">DAO</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=Jekyll"
            title="Jekyll"
            rel="1">Jekyll</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=Markdown"
            title="Markdown"
            rel="1">Markdown</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=amm"
            title="amm"
            rel="1">amm</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=analysis"
            title="analysis"
            rel="1">analysis</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=client+development"
            title="client development"
            rel="1">client development</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=dao"
            title="dao"
            rel="1">dao</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=devops"
            title="devops"
            rel="1">devops</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=gitops"
            title="gitops"
            rel="1">gitops</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=governance"
            title="governance"
            rel="1">governance</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=json+rpc"
            title="json rpc"
            rel="1">json rpc</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=nix"
            title="nix"
            rel="1">nix</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=protocol"
            title="protocol"
            rel="1">protocol</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=routing"
            title="routing"
            rel="1">routing</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=sushiswap"
            title="sushiswap"
            rel="1">sushiswap</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=tooling"
            title="tooling"
            rel="1">tooling</a><a data-sort="0016"
            href="/pages/manifoldfinance/primitives/archive/?tag=trading"
            title="trading"
            rel="1">trading</a>
    </div>
</section>
</div>
    </div>
  </div>
</article>
<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><!-- SNS -->
<ul class="list-inline text-center">
  
  <li>
    <a href="/pages/manifoldfinance/primitives/feed.xml">
      <span class="fa-stack fa-lg">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li><li>
    <a target="_blank" href="mailto:sam@manifoldfinance.com">
      <span class="fa-stack fa-lg">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li><li>
    <a target="_blank" href="https://github.com/manifoldfinance">
      <span class="fa-stack fa-lg">
        <i class="fas fa-circle fa-stack-2x fa-inverse"></i>
        <i class="fab fa-github fa-stack-2x"></i>
      </span>
    </a>
  </li><li>
    <a href="https://twitter.com/foldfinance">
      <span class="fa-stack fa-lg">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li></ul>
<p class="copyright text-muted">See
          <a href="https://github.com/sambacha"></a> @sambacha | &copy; 2022-2024 manifoldfinance
        </p>
      </div>
    </div>
  </div>
</footer>

<!-- jQuery -->
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"
  integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg=="
  crossorigin="anonymous"
></script>

<!-- Bootstrap JavaScript-->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script
  src="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"
  integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd"
  crossorigin="anonymous"
></script>

<!-- Simple Jekyll Search -->
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/simple-jekyll-search/1.7.12/simple-jekyll-search.min.js"
  integrity="sha512-APy7Ff/y4pdIHleqiTMcRZ8Wu6tjfqhJpgAcaCvTuFQPj/G+/A5u0uZi/DkfkuLQ6FeFmDJgh/zl0y3If/VUyA=="
  crossorigin="anonymous"
></script>

<!-- MathJax https://github.com/mathjax/MathJax/issues/2220 -->
<script>
  MathJax = {
    options: {
      renderActions: {
        /* add a new named action not to override the original 'find' action */
        find_script_mathtex: [
          10,
          function (doc) {
            for (const node of document.querySelectorAll(
              'script[type^="math/tex"]',
            )) {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(
                node.textContent,
                doc.inputJax[0],
                display,
              );
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = { node: text, delim: '', n: 0 };
              math.end = { node: text, delim: '', n: 0 };
              doc.math.push(math);
            }
          },
          '',
        ],
      },
    },
  };
</script>
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.5/es5/tex-chtml.js"
  integrity="sha512-WIPUeuVusAT6dUtN6xKArYCBEa76ltyvaz3ltvQd+dy7ISdGJv1Y3y7eDBEF986YfNtmZGLdAaEBSgeBb+8OSg=="
  crossorigin="anonymous"
></script>

<!-- Async load function -->
<script>
  function async(u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener(
        'load',
        function (e) {
          c(null, e);
        },
        false,
      );
    }
    s.parentNode.insertBefore(o, s);
  }
</script><!-- AnchorJS -->
<script>
  async(
    'https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js',
    function () {
      anchors.options = {
        visible: 'hover',
      };
      anchors
        .add()
        .remove('.intro-header h1')
        .remove('.subheading')
        .remove('.sidebar-container h5');
    },
  );
</script><!-- Custom JavaScript -->
<script src="/pages/manifoldfinance/primitives/assets/js/main.js"></script><!-- Side Catalog -->
<script src="/pages/manifoldfinance/primitives/assets/js/catalog.js"></script></body>
</html>
